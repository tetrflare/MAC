<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAC 3D Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #111827; color: #E5E7EB; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; overflow: hidden; touch-action: none; }
        #info { position: absolute; top: 10px; left: 10px; padding: 10px; background-color: rgba(17, 24, 39, 0.5); border-radius: 8px; z-index: 100; }
        #controls { position: absolute; top: 10px; right: 10px; padding: 1rem; background-color: rgba(17, 24, 39, 0.8); border-radius: 0.5rem; border: 1px solid #374151; width: 280px; z-index: 101; }
        #controls button:disabled { background-color: #374151; cursor: not-allowed; }
        #analysis-panel { position: absolute; bottom: 20px; left: 20px; background-color: rgba(17, 24, 39, 0.8); padding: 1rem; border-radius: 0.5rem; border: 1px solid #374151; width: 280px; z-index: 101; }
        #info h1 { color: #FFFFFF; }
        #info p, #controls label { color: #D1D5DB; }
        #analysis-results strong { color: #F3F4F6; }
    </style>
</head>
<body>
    <div id="info" class="text-white pointer-events-none">
        <h1 class="text-2xl font-bold">MAC 3D Viewer</h1>
        <p class="text-sm">Drag to rotate | Scroll to zoom | Right-click drag to pan</p>
        <p id="status" class="text-xs mt-2 bg-gray-800 bg-opacity-50 inline-block px-2 py-1 rounded" style="display: none;"></p>
    </div>
    <div id="controls">
        <div class="mb-4">
            <label for="model-size" class="text-sm text-gray-200">Model Size (<span id="model-size-value">4</span> units)</label>
            <input id="model-size" type="range" min="2" max="8" step="1" value="4" class="w-full">
        </div>
        <div class="mb-4">
            <label for="packing-density" class="text-sm text-gray-200">Initial Packing Density (<span id="packing-density-value">0</span>%)</label>
            <input id="packing-density" type="range" min="-20" max="20" step="1" value="0" class="w-full">
        </div>
        <div class="mb-4">
            <label for="num-defects" class="text-sm text-gray-200">Number of Defects (<span id="num-defects-value">300</span>)</label>
            <input id="num-defects" type="range" min="0" max="1000" value="300" class="w-full">
        </div>
        <div class="mb-4">
            <label for="relax-iterations" class="text-sm text-gray-200">Relaxation Iterations (<span id="relax-iterations-value">500</span>)</label>
            <input id="relax-iterations" type="range" min="0" max="5000" value="500" class="w-full">
        </div>
        <div class="mb-4">
            <label for="bond-length-strength" class="text-sm text-gray-200">Bond Length Strength (<span id="bond-length-strength-value">0.2</span>)</label>
            <input id="bond-length-strength" type="range" min="0" max="1.0" step="0.01" value="0.2" class="w-full">
        </div>
        <div class="mb-4">
            <label for="bond-angle-strength" class="text-sm text-gray-200">Bond Angle Strength (<span id="bond-angle-strength-value">0.002</span>)</label>
            <input id="bond-angle-strength" type="range" min="0.0" max="0.01" step="0.0005" value="0.002" class="w-full">
        </div>
        <div class="mb-4">
            <label for="pristine-angle-strength" class="text-sm text-gray-200">Pristine Angle Strength (<span id="pristine-angle-strength-value">0.2</span>)</label>
            <input id="pristine-angle-strength" type="range" min="0.0" max="1.0" step="0.01" value="0.2" class="w-full">
        </div>
        <div class="mb-4">
            <label for="z-displacement-strength" class="text-sm text-gray-200">Initial Z-Displacement (<span id="z-displacement-strength-value">0.1</span>)</label>
            <input id="z-displacement-strength" type="range" min="0.0" max="1.0" step="0.01" value="0.1" class="w-full">
        </div>
        <div class="mb-4">
            <label for="planarity-strength" class="text-sm text-gray-200">Planarity Strength (<span id="planarity-strength-value">0.005</span>)</label>
            <input id="planarity-strength" type="range" min="0.0" max="0.05" step="0.001" value="0.005" class="w-full">
        </div>
        <div class="mb-4">
            <label for="rotation-angle" class="text-sm text-gray-200">Rotation Angle (<span id="rotation-angle-value">5</span>Â°)</label>
            <input id="rotation-angle" type="range" min="0" max="30" step="1" value="5" class="w-full">
        </div>
        <button id="regenerate-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Regenerate</button>
        <button id="export-csv-btn" class="mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">Export CSV</button>
    </div>
    <div id="analysis-panel" class="hidden">
        <h3 class="text-lg font-bold mb-2 text-gray-200">Ring Analysis</h3>
        <div id="analysis-results"></div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls, currentModel;
        const statusElement = document.getElementById('status');
        
        const 
            modelSizeSlider = document.getElementById('model-size'),
            packingDensitySlider = document.getElementById('packing-density'),
            numDefectsSlider = document.getElementById('num-defects'),
            relaxIterationsSlider = document.getElementById('relax-iterations'),
            bondLengthStrengthSlider = document.getElementById('bond-length-strength'),
            bondAngleStrengthSlider = document.getElementById('bond-angle-strength'),
            pristineAngleStrengthSlider = document.getElementById('pristine-angle-strength'),
            zDisplacementStrengthSlider = document.getElementById('z-displacement-strength'),
            planarityStrengthSlider = document.getElementById('planarity-strength'),
            rotationAngleSlider = document.getElementById('rotation-angle'),
            modelSizeValue = document.getElementById('model-size-value'),
            packingDensityValue = document.getElementById('packing-density-value'),
            numDefectsValue = document.getElementById('num-defects-value'),
            relaxIterationsValue = document.getElementById('relax-iterations-value'),
            bondLengthStrengthValue = document.getElementById('bond-length-strength-value'),
            bondAngleStrengthValue = document.getElementById('bond-angle-strength-value'),
            pristineAngleStrengthValue = document.getElementById('pristine-angle-strength-value'),
            zDisplacementStrengthValue = document.getElementById('z-displacement-strength-value'),
            planarityStrengthValue = document.getElementById('planarity-strength-value'),
            rotationAngleValue = document.getElementById('rotation-angle-value'),
            regenerateBtn = document.getElementById('regenerate-btn'),
            exportCsvBtn = document.getElementById('export-csv-btn');

        const yieldToMain = () => new Promise(resolve => setTimeout(resolve, 10));

        const distToSegment2D = (p, segStart, segEnd) => {
            const dx = segEnd.x - segStart.x, dy = segEnd.y - segStart.y;
            const l2 = dx * dx + dy * dy;
            if (l2 === 0) return Math.hypot(p.x - segStart.x, p.y - segStart.y);
            let t = Math.max(0, Math.min(1, ((p.x - segStart.x) * dx + (p.y - segStart.y) * dy) / l2));
            const proj_x = segStart.x + t * dx, proj_y = segStart.y + t * dy;
            return Math.hypot(p.x - proj_x, p.y - proj_y);
        };

        const config = {
            C_C_BOND_LENGTH: 1.42,
            IDEAL_BOND_ANGLE: 2 * Math.PI / 3, // 120 degrees
            BOND_THRESHOLD_FACTOR: 1.2,
            MIN_BOND_LENGTH_FACTOR: 0.8,
            ATOM_RADIUS: 0.3,
            BOND_RADIUS: 0.08,
        };
        
        function generateGrapheneLattice(numCellsX, numCellsY, packingFactor, angleInDegrees) {
            statusElement.textContent = 'Generating initial lattice...';
            const atomMap = new Map();
            const atom_dist = config.C_C_BOND_LENGTH * packingFactor;
            const a1 = new THREE.Vector3(atom_dist * 3 / 2, atom_dist * Math.sqrt(3) / 2, 0);
            const a2 = new THREE.Vector3(atom_dist * 3 / 2, -atom_dist * Math.sqrt(3) / 2, 0);
            const b1 = new THREE.Vector3(0, 0, 0), b2 = new THREE.Vector3(atom_dist, 0, 0);

            const baseUnitCellAtoms = [];
            const unitSize = 4;
            const unitCellBox = new THREE.Box3();
            for (let i = 0; i < unitSize; i++) {
                for (let j = 0; j < unitSize; j++) {
                    const R = new THREE.Vector3().addScaledVector(a1, i).addScaledVector(a2, j);
                    const p1 = new THREE.Vector3().addVectors(R, b1);
                    const p2 = new THREE.Vector3().addVectors(R, b2);
                    baseUnitCellAtoms.push(p1, p2);
                    unitCellBox.expandByPoint(p1);
                    unitCellBox.expandByPoint(p2);
                }
            }
            const unitCellCenter = unitCellBox.getCenter(new THREE.Vector3());
            const rotationAngle = angleInDegrees * (Math.PI / 180);
            const rotationAxis = new THREE.Vector3(0, 0, 1);
            const translationVectorX = new THREE.Vector3().addScaledVector(a1, unitSize);
            const translationVectorY = new THREE.Vector3().addScaledVector(a2, unitSize);
            const numTranslationsX = Math.ceil(numCellsX / unitSize), numTranslationsY = Math.ceil(numCellsY / unitSize);

            for (let m = -numTranslationsX; m <= numTranslationsX; m++) {
                for (let n = -numTranslationsY; n <= numTranslationsY; n++) {
                    const totalTranslation = new THREE.Vector3().addScaledVector(translationVectorX, m).addScaledVector(translationVectorY, n);
                    const isRotatedTile = (m + n) % 2 !== 0;
                    if (isRotatedTile) {
                        const tileCenter = new THREE.Vector3().addVectors(totalTranslation, unitCellCenter);
                        baseUnitCellAtoms.forEach(atomLocalPos => {
                            const posRelativeToUnitCenter = new THREE.Vector3().subVectors(atomLocalPos, unitCellCenter);
                            posRelativeToUnitCenter.applyAxisAngle(rotationAxis, rotationAngle);
                            const finalPos = new THREE.Vector3().addVectors(posRelativeToUnitCenter, tileCenter);
                            const key = `${finalPos.x.toFixed(4)},${finalPos.y.toFixed(4)},${finalPos.z.toFixed(4)}`;
                            if (!atomMap.has(key)) atomMap.set(key, { pos: [finalPos.x, finalPos.y, finalPos.z], tile: { m, n } });
                        });
                    } else {
                        baseUnitCellAtoms.forEach(atomPos => {
                            const newPos = new THREE.Vector3().addVectors(atomPos, totalTranslation);
                            const key = `${newPos.x.toFixed(4)},${newPos.y.toFixed(4)},${newPos.z.toFixed(4)}`;
                            if (!atomMap.has(key)) atomMap.set(key, { pos: [newPos.x, newPos.y, newPos.z], tile: { m, n } });
                        });
                    }
                }
            }
            return Array.from(atomMap.values());
        }

        async function introduceStoneWalesDefects(atomData, defectCount, threshold) {
            statusElement.textContent = 'Introducing defects...';
            if (defectCount === 0) return atomData;
            let positions = atomData.map(a => new THREE.Vector3(...a.pos));
            let createdDefects = 0, totalAttempts = 0;
            const maxTotalAttempts = defectCount * 200; 
            const defectsPerChunk = 50;

            while (createdDefects < defectCount && totalAttempts < maxTotalAttempts) {
                totalAttempts++;
                const adj = new Map(positions.map((_, i) => [i, []]));
                const bonds = [];
                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        if (positions[i].distanceTo(positions[j]) < threshold) {
                            adj.get(i).push(j);
                            adj.get(j).push(i);
                            bonds.push([i, j]);
                        }
                    }
                }
                if (bonds.length === 0) break;
                const [i, j] = bonds[Math.floor(Math.random() * bonds.length)];
                if (adj.get(i).length !== 3 || adj.get(j).length !== 3) continue; 
                const p_i = positions[i], p_j = positions[j];
                const midpoint = new THREE.Vector3().addVectors(p_i, p_j).multiplyScalar(0.5);
                const rotationAxis = new THREE.Vector3(0, 0, 1);
                const p_i_new = p_i.clone().sub(midpoint).applyAxisAngle(rotationAxis, Math.PI / 2).add(midpoint);
                const p_j_new = p_j.clone().sub(midpoint).applyAxisAngle(rotationAxis, Math.PI / 2).add(midpoint);
                let clashes = false;
                const minDistance = config.C_C_BOND_LENGTH * config.MIN_BOND_LENGTH_FACTOR;
                for (let k = 0; k < positions.length; k++) {
                    if (k === i || k === j) continue;
                    const p_k = positions[k];
                    if (p_i_new.distanceTo(p_k) < minDistance || p_j_new.distanceTo(p_k) < minDistance) {
                        clashes = true;
                        break;
                    }
                }
                if (!clashes) {
                    positions[i].copy(p_i_new);
                    positions[j].copy(p_j_new);
                    createdDefects++;
                    if (createdDefects % defectsPerChunk === 0 && createdDefects < defectCount) {
                        statusElement.textContent = `Introducing defects... (${createdDefects}/${defectCount})`;
                        await yieldToMain();
                    }
                }
            }
            statusElement.textContent = `Introducing defects... (${createdDefects}/${defectCount})`;
            console.log(`Successfully introduced ${createdDefects} defects after ${totalAttempts} attempts.`);
            return atomData.map((data, i) => ({ pos: [positions[i].x, positions[i].y, positions[i].z], tile: data.tile }));
        }
        
        function addInitialZDisplacement(atomData, zStrength) {
            if (zStrength === 0) return atomData;
            statusElement.textContent = 'Applying initial Z-displacement...';
            return atomData.map(data => ({ pos: [data.pos[0], data.pos[1], (Math.random() - 0.5) * zStrength], tile: data.tile }));
        }

        function determineBondNetwork(atoms) {
            statusElement.textContent = 'Determining 3-bond network...';
            const bonds = new Set(), atomVectors = atoms.map(a => new THREE.Vector3(...a));
            for (let i = 0; i < atomVectors.length; i++) {
                const neighbors = [];
                for (let j = 0; j < atomVectors.length; j++) {
                    if (i === j) continue;
                    neighbors.push({ index: j, distance: atomVectors[i].distanceTo(atomVectors[j]) });
                }
                neighbors.sort((a, b) => a.distance - b.distance);
                for (const neighbor of neighbors.slice(0, 3)) {
                    bonds.add(`${Math.min(i, neighbor.index)}-${Math.max(i, neighbor.index)}`);
                }
            }
            return Array.from(bonds).map(b => b.split('-').map(Number));
        }

        function refineBondNetwork(atomPositions, initialBonds) {
            statusElement.textContent = 'Refining bond network...';
            const atomVectors = atomPositions.map(p => new THREE.Vector3(...p));
            const bonds = new Set(initialBonds.map(b => `${Math.min(b[0], b[1])}-${Math.max(b[0], b[1])}`));
            const findAndRemoveSmallestRings = (currentBonds, adj) => {
                const bondsToRemove = new Set(), bondsBroken = new Set();
                for (let i = 0; i < atomVectors.length; i++) {
                    const neighbors = adj.get(i);
                    if (neighbors.length < 2) continue;
                    for (let j_idx = 0; j_idx < neighbors.length; j_idx++) {
                        for (let k_idx = j_idx + 1; k_idx < neighbors.length; k_idx++) {
                            const j = neighbors[j_idx], k = neighbors[k_idx];
                            if (adj.get(j).includes(k)) {
                                const ringBonds = [ { atoms: [i, j], dist: atomVectors[i].distanceTo(atomVectors[j]) }, { atoms: [j, k], dist: atomVectors[j].distanceTo(atomVectors[k]) }, { atoms: [k, i], dist: atomVectors[k].distanceTo(atomVectors[i]) } ];
                                ringBonds.sort((a, b) => b.dist - a.dist);
                                const bondKey = `${Math.min(...ringBonds[0].atoms)}-${Math.max(...ringBonds[0].atoms)}`;
                                if (!bondsBroken.has(bondKey)) { bondsToRemove.add(bondKey); bondsBroken.add(bondKey); }
                            }
                        }
                    }
                }
                for (let i = 0; i < atomVectors.length; i++) {
                    const neighborsOfI = adj.get(i);
                    if (neighborsOfI.length < 2) continue;
                    for (let j_idx = 0; j_idx < neighborsOfI.length; j_idx++) {
                        for (let k_idx = j_idx + 1; k_idx < neighborsOfI.length; k_idx++) {
                            const j = neighborsOfI[j_idx], l = neighborsOfI[k_idx];
                            const commonNeighbors = adj.get(j).filter(n => n !== i && adj.get(l).includes(n));
                            for (const k of commonNeighbors) {
                                 const ringBonds = [ {atoms: [i,j], dist: atomVectors[i].distanceTo(atomVectors[j])}, {atoms: [j,k], dist: atomVectors[j].distanceTo(atomVectors[k])}, {atoms: [k,l], dist: atomVectors[k].distanceTo(atomVectors[l])}, {atoms: [l,i], dist: atomVectors[l].distanceTo(atomVectors[i])} ];
                                 ringBonds.sort((a,b)=>b.dist - a.dist);
                                 const bondKey = `${Math.min(...ringBonds[0].atoms)}-${Math.max(...ringBonds[0].atoms)}`;
                                 if (!bondsBroken.has(bondKey)) { bondsToRemove.add(bondKey); bondsBroken.add(bondKey); }
                            }
                        }
                    }
                }
                bondsToRemove.forEach(bondKey => {
                    if (currentBonds.has(bondKey)) {
                        currentBonds.delete(bondKey);
                        const [u, v] = bondKey.split('-').map(Number);
                        adj.set(u, adj.get(u).filter(n => n !== v));
                        adj.set(v, adj.get(v).filter(n => n !== u));
                    }
                });
                return bondsToRemove;
            };

            for (let iter = 0; iter < 10; iter++) {
                let changesMade = false;
                const adj = new Map(atomVectors.map((_, i) => [i, []]));
                for(const bondKey of bonds) { const [u,v] = bondKey.split('-').map(Number); adj.get(u).push(v); adj.get(v).push(u); }
                const bondsBrokenThisCycle = findAndRemoveSmallestRings(bonds, adj);
                if (bondsBrokenThisCycle.size > 0) changesMade = true;
                let overCoordChanges = false;
                for(let i=0; i<atomVectors.length; i++) {
                    if (adj.get(i).length > 3) {
                        const neighbors = adj.get(i);
                        neighbors.sort((a, b) => atomVectors[i].distanceTo(atomVectors[a]) - atomVectors[i].distanceTo(atomVectors[b]));
                        for(const neighborToRemove of neighbors.slice(3)) {
                            const bondKey = `${Math.min(i, neighborToRemove)}-${Math.max(i, neighborToRemove)}`;
                            if(bonds.has(bondKey)) { bonds.delete(bondKey); adj.set(i, adj.get(i).filter(n => n !== neighborToRemove)); adj.set(neighborToRemove, adj.get(neighborToRemove).filter(n => n !== i)); overCoordChanges = true; }
                        }
                    }
                }
                if (overCoordChanges) changesMade = true;
                let underCoordChanges = false;
                for(let i=0; i<atomVectors.length; i++) {
                    if(adj.get(i).length < 3) {
                        const candidates = [];
                        for(let j=0; j<atomVectors.length; j++) {
                           if(i === j || adj.get(i).includes(j)) continue;
                           const dist = atomVectors[i].distanceTo(atomVectors[j]);
                           if(dist < config.C_C_BOND_LENGTH * 1.6) candidates.push({index: j, distance: dist, coord: adj.get(j)?.length || 0});
                        }
                        candidates.sort((a,b) => (a.coord < 3 && b.coord >= 3) ? -1 : (a.coord >= 3 && b.coord < 3) ? 1 : a.distance - b.distance);
                        for(const candidate of candidates) {
                            if(adj.get(i).length >= 3) break;
                            const j = candidate.index;
                            if (adj.get(j) && adj.get(j).length > 3) continue;
                            const bondKey = `${Math.min(i, j)}-${Math.max(i, j)}`;
                            if (bondsBrokenThisCycle.has(bondKey)) continue;
                            if(!bonds.has(bondKey) && !checkIfFormsSmallRing(i, j, adj)) { bonds.add(bondKey); adj.get(i).push(j); if (!adj.has(j)) adj.set(j, []); adj.get(j).push(i); underCoordChanges = true; }
                        }
                    }
                }
                if (underCoordChanges) changesMade = true;
                if (!changesMade) break;
            }
            return Array.from(bonds).map(b => b.split('-').map(Number));
        }
        
        function checkIfFormsSmallRing(u, v, adj) {
            const uNeighbors = adj.get(u), vNeighbors = adj.get(v);
            for(const n of uNeighbors) if(vNeighbors.includes(n)) return true;
            for (const u_neighbor of uNeighbors) for (const v_neighbor of vNeighbors) if (adj.get(u_neighbor).includes(v_neighbor)) return true;
            return false;
        }

        async function relaxStructure(atomData, bonds, iterations, lengthStrength, angleStrength, pristineAngleStrength, planarityStrength, defectiveAtoms, idealLength, idealAngle) {
             console.log(`Relaxing structure for ${iterations} iterations...`);
             let positions = atomData.map(a => new THREE.Vector3(...a.pos));
             const adj = new Map(positions.map((_, i) => [i, []]));
             for(const [u,v] of bonds) { adj.get(u).push(v); adj.get(v).push(u); }
             const iterationsPerChunk = 1000;

             for (let i = 0; i < iterations; i++) {
                const forces = positions.map(() => new THREE.Vector3(0, 0, 0));
                for (const [j, k] of bonds) {
                    const p1 = positions[j], p2 = positions[k];
                    const delta = new THREE.Vector3().subVectors(p2, p1);
                    const distance = delta.length();
                    if (distance > 0.1) {
                        const force = delta.normalize().multiplyScalar(lengthStrength * (distance - idealLength));
                        forces[j].add(force);
                        forces[k].sub(force);
                    }
                }
                if (angleStrength > 0) {
                    const effectiveAngleStrength = angleStrength * 10; 
                    for (let j = 0; j < positions.length; j++) {
                        const neighbors = adj.get(j);
                        if (neighbors.length < 2) continue;
                        for (let n1 = 0; n1 < neighbors.length; n1++) {
                            for (let n2 = n1 + 1; n2 < neighbors.length; n2++) {
                                const v1 = new THREE.Vector3().subVectors(positions[neighbors[n1]], positions[j]);
                                const v2 = new THREE.Vector3().subVectors(positions[neighbors[n2]], positions[j]);
                                if (v1.lengthSq() === 0 || v2.lengthSq() === 0) continue;
                                let forceMagnitude = effectiveAngleStrength * (v1.angleTo(v2) - idealAngle);
                                if (!defectiveAtoms.has(j)) forceMagnitude *= pristineAngleStrength;
                                const cross = new THREE.Vector3().crossVectors(v1, v2);
                                if (cross.lengthSq() > 1e-8) {
                                    const forceDir1 = new THREE.Vector3().crossVectors(v1, v2).cross(v1).normalize();
                                    forces[neighbors[n1]].add(forceDir1.multiplyScalar(forceMagnitude));
                                    const forceDir2 = new THREE.Vector3().crossVectors(v2, v1).cross(v2).normalize();
                                    forces[neighbors[n2]].add(forceDir2.multiplyScalar(forceMagnitude));
                                }
                            }
                        }
                    }
                }
                if (planarityStrength > 0) {
                    const effectivePlanarityStrength = planarityStrength * 5.0; 
                    for (let j = 0; j < positions.length; j++) {
                        const neighbors_indices = adj.get(j);
                        if (neighbors_indices.length !== 3) continue;
                        const p_n1 = positions[neighbors_indices[0]], p_n2 = positions[neighbors_indices[1]], p_n3 = positions[neighbors_indices[2]];
                        const normal = new THREE.Vector3().crossVectors(new THREE.Vector3().subVectors(p_n2, p_n1), new THREE.Vector3().subVectors(p_n3, p_n1));
                        if (normal.lengthSq() < 1e-8) continue;
                        normal.normalize();
                        const dist = new THREE.Vector3().subVectors(positions[j], p_n1).dot(normal);
                        const force = normal.clone().multiplyScalar(-effectivePlanarityStrength * dist);
                        forces[j].add(force);
                        const reactionForce = force.clone().multiplyScalar(-1/3);
                        forces[neighbors_indices[0]].add(reactionForce);
                        forces[neighbors_indices[1]].add(reactionForce);
                        forces[neighbors_indices[2]].add(reactionForce);
                    }
                }
                positions.forEach((pos, index) => pos.add(forces[index]));
                
                if ((i + 1) % iterationsPerChunk === 0 && i < iterations -1) {
                    statusElement.textContent = `Relaxing structure... (Iteration ${i + 1}/${iterations})`;
                    await yieldToMain();
                }
            }
            statusElement.textContent = 'Relaxation complete.';
            return atomData.map((data, i) => ({ pos: [positions[i].x, positions[i].y, positions[i].z], tile: data.tile }));
        }

        function analyzeRings(bonds, numAtoms, edgeAtoms) {
            statusElement.textContent = 'Analyzing ring structure...';
            const adj = new Map();
            for (let i = 0; i < numAtoms; i++) adj.set(i, []);
            for (const [u, v] of bonds) { adj.get(u).push(v); adj.get(v).push(u); }
            const ringCounts = { 3:0, 4:0, 5: 0, 6: 0, 7: 0, 8: 0, "9+": 0 }, bondsInNonSixRings = new Set();
            const bfs = (start, end, excludedNodes = new Set()) => {
                const q = [[start, [start]]], visited = new Set([start, ...excludedNodes]);
                while (q.length > 0) {
                    const [curr, path] = q.shift();
                    if (curr === end) return path;
                    for (const neighbor of (adj.get(curr) || [])) {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            q.push([neighbor, [...path, neighbor]]);
                        }
                    }
                }
                return null;
            };

            for (const [u, v] of bonds) {
                if (edgeAtoms.has(u) || edgeAtoms.has(v)) continue;
                const adj_u = adj.get(u), adj_v = adj.get(v);
                adj.set(u, adj_u.filter(n => n !== v));
                adj.set(v, adj_v.filter(n => n !== u));
                let inNonSix = false;
                const path1 = bfs(u, v);
                if (path1) {
                    const size1 = path1.length;
                    if (size1 !== 6) inNonSix = true;
                    if (ringCounts.hasOwnProperty(size1)) ringCounts[size1] += 1 / size1;
                    else if (size1 >= 9) ringCounts["9+"] += 1 / size1;
                    const path2 = bfs(u, v, new Set(path1.slice(1, -1)));
                    if (path2) {
                        const size2 = path2.length;
                         if (size2 !== 6) inNonSix = true;
                         if (ringCounts.hasOwnProperty(size2)) ringCounts[size2] += 1 / size2;
                         else if (size2 >= 9) ringCounts["9+"] += 1 / size2;
                    }
                } else inNonSix = true;
                if(inNonSix) bondsInNonSixRings.add(`${Math.min(u,v)}-${Math.max(u,v)}`);
                adj.set(u, adj_u);
                adj.set(v, adj_v);
            }
            
            const totalRings = Object.values(ringCounts).reduce((s, v) => s + v, 0);
            const resultsDiv = document.getElementById('analysis-results');
            if (totalRings === 0) {
                resultsDiv.innerHTML = '<p class="text-sm text-gray-400">No rings found.</p>';
            } else {
                let html = '';
                const categories = [ { size: 3, label: '3-Membered' }, { size: 4, label: '4-Membered' }, { size: 5, label: '5-Membered' }, { size: 6, label: '6-Membered' }, { size: 7, label: '7-Membered' }, { size: 8, label: '8-Membered' }, { size: "9+", label: '9+ Membered' } ];
                for (const cat of categories) {
                    const count = ringCounts[cat.size] || 0;
                    const fraction = totalRings > 0 ? (count / totalRings) * 100 : 0;
                    html += `<p class="text-sm text-gray-300 flex justify-between"><strong>${cat.label}:</strong> <span>${Math.round(count)} <span class="text-gray-500">(${fraction.toFixed(1)}%)</span></span></p>`;
                }
                resultsDiv.innerHTML = html;
            }
            document.getElementById('analysis-panel').classList.remove('hidden');
            return { bondsInNonSixRings };
        }
        
        function createBond(p1, p2, material, group) {
            const bondDir = new THREE.Vector3().subVectors(p2, p1);
            const bondLength = bondDir.length();
            if (bondLength === 0) return;
            const bondGeometry = new THREE.CylinderGeometry(config.BOND_RADIUS, config.BOND_RADIUS, bondLength, 8);
            const bondMesh = new THREE.Mesh(bondGeometry, material);
            bondMesh.position.copy(p1).add(bondDir.multiplyScalar(0.5));
            bondMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), bondDir.normalize());
            group.add(bondMesh);
        }

        function createModel(atomData, bonds, bondsInNonSixRings, edgeAtoms) {
            const atomGroup = new THREE.Group(), bondGroup = new THREE.Group();
            const blueAtomMaterial = new THREE.MeshStandardMaterial({ color: 0x2563eb, roughness: 0.5 }), blueBondMaterial = new THREE.MeshStandardMaterial({ color: 0x1d4ed8, roughness: 0.5 }), greyAtomMaterial = new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness: 0.5 }), greyBondMaterial = new THREE.MeshStandardMaterial({ color: 0x4b5563, roughness: 0.5 }), edgeAtomMaterial = new THREE.MeshStandardMaterial({ color: 0x8b5cf6, roughness: 0.5 }), edgeBondMaterial = new THREE.MeshStandardMaterial({ color: 0x7c3aed, roughness: 0.5 });
            const atoms = atomData.map(data => ({ pos: new THREE.Vector3(...data.pos), tile: data.tile }));
            const defectiveAtoms = new Set();
            bondsInNonSixRings.forEach(bondKey => { const [u, v] = bondKey.split('-').map(Number); defectiveAtoms.add(u); defectiveAtoms.add(v); });
            const atomGeometry = new THREE.SphereGeometry(config.ATOM_RADIUS, 16, 16);
            atoms.forEach((atom, i) => {
                const material = edgeAtoms.has(i) ? edgeAtomMaterial : defectiveAtoms.has(i) ? greyAtomMaterial : blueAtomMaterial;
                const atomMesh = new THREE.Mesh(atomGeometry, material);
                atomMesh.position.copy(atom.pos);
                atomGroup.add(atomMesh);
            });
            for (const [i, j] of bonds) {
                const bondKey = `${Math.min(i, j)}-${Math.max(i, j)}`;
                const material = (edgeAtoms.has(i) || edgeAtoms.has(j)) ? edgeBondMaterial : bondsInNonSixRings.has(bondKey) ? greyBondMaterial : blueBondMaterial;
                createBond(atoms[i].pos, atoms[j].pos, material, bondGroup);
            }
            const modelGroup = new THREE.Group();
            modelGroup.add(atomGroup, bondGroup);
            const center = new THREE.Box3().setFromObject(modelGroup).getCenter(new THREE.Vector3());
            modelGroup.position.sub(center);
            return modelGroup;
        }
        
        async function generateInitialLatticeView() {
            if (currentModel) scene.remove(currentModel);
            exportCsvBtn.disabled = true;

            statusElement.style.display = 'inline-block';
            statusElement.textContent = 'Generating initial lattice...';
            await yieldToMain();

            const modelSizeUnits = parseInt(modelSizeSlider.value);
            const packingDensity = parseInt(packingDensitySlider.value);
            const rotationAngle = parseInt(rotationAngleSlider.value);
            const packingFactor = 1 - (packingDensity / 100);
            const numCells = modelSizeUnits * 4;

            let initialAtoms = generateGrapheneLattice(numCells, numCells, packingFactor, rotationAngle);
            await yieldToMain();

            const atomPositions = initialAtoms.map(d => d.pos);
            let bondNetwork = determineBondNetwork(atomPositions);
            await yieldToMain();

            const edgeAtoms = new Set(), edgeThreshold = 3.0;
            const atomsForEdgeDetection = initialAtoms.map(data => ({ pos: new THREE.Vector3(...data.pos) }));
            if (atomsForEdgeDetection.length > 0) {
                let minXAtom = atomsForEdgeDetection[0], maxXAtom = atomsForEdgeDetection[0], minYAtom = atomsForEdgeDetection[0], maxYAtom = atomsForEdgeDetection[0];
                for (let i = 1; i < atomsForEdgeDetection.length; i++) {
                    if (atomsForEdgeDetection[i].pos.x < minXAtom.pos.x) minXAtom = atomsForEdgeDetection[i];
                    if (atomsForEdgeDetection[i].pos.x > maxXAtom.pos.x) maxXAtom = atomsForEdgeDetection[i];
                    if (atomsForEdgeDetection[i].pos.y < minYAtom.pos.y) minYAtom = atomsForEdgeDetection[i];
                    if (atomsForEdgeDetection[i].pos.y > maxYAtom.pos.y) maxYAtom = atomsForEdgeDetection[i];
                }
                const segments = [ [minXAtom.pos, maxYAtom.pos], [maxYAtom.pos, maxXAtom.pos], [maxXAtom.pos, minYAtom.pos], [minYAtom.pos, minXAtom.pos] ];
                atomsForEdgeDetection.forEach((atom, i) => {
                    let minDistance = Infinity;
                    for (const seg of segments) {
                        const distance = distToSegment2D(atom.pos, seg[0], seg[1]);
                        if (distance < minDistance) minDistance = distance;
                    }
                    if (minDistance < edgeThreshold) edgeAtoms.add(i);
                });
            }
            
            statusElement.textContent = 'Creating 3D objects...';
            await yieldToMain();

            currentModel = createModel(initialAtoms, bondNetwork, new Set(), edgeAtoms);
            scene.add(currentModel);
            
            document.getElementById('analysis-panel').classList.add('hidden');
            statusElement.style.display = 'none';
            exportCsvBtn.disabled = false;

            const boundingBox = new THREE.Box3().setFromObject(currentModel);
            const modelCenter = boundingBox.getCenter(new THREE.Vector3());
            const modelSize = Math.max(...boundingBox.getSize(new THREE.Vector3()).toArray());
            const cameraDistance = (modelSize / 2) / Math.tan(camera.fov * (Math.PI / 180) / 2);
            camera.position.set(modelCenter.x, modelCenter.y, modelCenter.z + cameraDistance * 1.2);
            camera.near = cameraDistance / 100;
            camera.far = cameraDistance * 100;
            camera.updateProjectionMatrix();
            controls.target.copy(modelCenter);
            controls.update();
        }

        async function regenerateModel() {
            regenerateBtn.disabled = true;
            regenerateBtn.textContent = 'Generating...';
            exportCsvBtn.disabled = true;
            if (currentModel) scene.remove(currentModel);
            statusElement.style.display = 'inline-block';
            
            await yieldToMain();

            const modelSizeUnits = parseInt(modelSizeSlider.value), packingDensity = parseInt(packingDensitySlider.value), numDefects = parseInt(numDefectsSlider.value), relaxIterations = parseInt(relaxIterationsSlider.value), lengthStrength = parseFloat(bondLengthStrengthSlider.value), angleStrength = parseFloat(bondAngleStrengthSlider.value), pristineAngleStrength = parseFloat(pristineAngleStrengthSlider.value), zStrength = parseFloat(zDisplacementStrengthSlider.value), planarityStrength = parseFloat(planarityStrengthSlider.value), rotationAngle = parseInt(rotationAngleSlider.value);
            const packingFactor = 1 - (packingDensity / 100), bondThreshold = config.C_C_BOND_LENGTH * config.BOND_THRESHOLD_FACTOR * packingFactor;
            const numCells = modelSizeUnits * 4;
            
            let initialAtoms = generateGrapheneLattice(numCells, numCells, packingFactor, rotationAngle);
            await yieldToMain();

            let defectedAtoms = await introduceStoneWalesDefects(initialAtoms, numDefects, bondThreshold);
            await yieldToMain();

            let displacedAtoms = addInitialZDisplacement(defectedAtoms, zStrength);
            await yieldToMain();
            
            const atomPositions = displacedAtoms.map(d => d.pos);
            let initialBondNetwork = determineBondNetwork(atomPositions);
            await yieldToMain();
            
            let bondNetwork = refineBondNetwork(atomPositions, initialBondNetwork);
            await yieldToMain();
            
            const edgeAtoms = new Set(), edgeThreshold = 3.0;
            const atomsForEdgeDetection = displacedAtoms.map(data => ({ pos: new THREE.Vector3(...data.pos) }));
            if (atomsForEdgeDetection.length > 0) {
                let minXAtom = atomsForEdgeDetection[0], maxXAtom = atomsForEdgeDetection[0], minYAtom = atomsForEdgeDetection[0], maxYAtom = atomsForEdgeDetection[0];
                for (let i = 1; i < atomsForEdgeDetection.length; i++) {
                    if (atomsForEdgeDetection[i].pos.x < minXAtom.pos.x) minXAtom = atomsForEdgeDetection[i];
                    if (atomsForEdgeDetection[i].pos.x > maxXAtom.pos.x) maxXAtom = atomsForEdgeDetection[i];
                    if (atomsForEdgeDetection[i].pos.y < minYAtom.pos.y) minYAtom = atomsForEdgeDetection[i];
                    if (atomsForEdgeDetection[i].pos.y > maxYAtom.pos.y) maxYAtom = atomsForEdgeDetection[i];
                }
                const segments = [ [minXAtom.pos, maxYAtom.pos], [maxYAtom.pos, maxXAtom.pos], [maxXAtom.pos, minYAtom.pos], [minYAtom.pos, minXAtom.pos] ];
                atomsForEdgeDetection.forEach((atom, i) => {
                    let minDistance = Infinity;
                    for (const seg of segments) {
                        const distance = distToSegment2D(atom.pos, seg[0], seg[1]);
                        if (distance < minDistance) minDistance = distance;
                    }
                    if (minDistance < edgeThreshold) edgeAtoms.add(i);
                });
            }
            
            const analysisResult = analyzeRings(bondNetwork, displacedAtoms.length, edgeAtoms);
            await yieldToMain();

            const defectiveAtoms = new Set();
            analysisResult.bondsInNonSixRings.forEach(bondKey => { const [u, v] = bondKey.split('-').map(Number); defectiveAtoms.add(u); defectiveAtoms.add(v); });

            let relaxedAtoms = await relaxStructure(displacedAtoms, bondNetwork, relaxIterations, lengthStrength, angleStrength, pristineAngleStrength, planarityStrength, defectiveAtoms, config.C_C_BOND_LENGTH, config.IDEAL_BOND_ANGLE);
            await yieldToMain();
            
            statusElement.textContent = 'Creating 3D objects...';
            await yieldToMain();

            currentModel = createModel(relaxedAtoms, bondNetwork, analysisResult.bondsInNonSixRings, edgeAtoms);
            scene.add(currentModel);
            statusElement.style.display = 'none';
            regenerateBtn.disabled = false;
            regenerateBtn.textContent = 'Regenerate';
            exportCsvBtn.disabled = false;

            const boundingBox = new THREE.Box3().setFromObject(currentModel);
            const modelCenter = boundingBox.getCenter(new THREE.Vector3());
            const modelSize = Math.max(...boundingBox.getSize(new THREE.Vector3()).toArray());
            const cameraDistance = (modelSize / 2) / Math.tan(camera.fov * (Math.PI / 180) / 2);
            camera.position.set(modelCenter.x, modelCenter.y, modelCenter.z + cameraDistance * 1.2);
            camera.near = cameraDistance / 100;
            camera.far = cameraDistance * 100;
            camera.updateProjectionMatrix();
            controls.target.copy(modelCenter);
            controls.update();
        }

        function exportModelToCsv() {
            if (!currentModel) return console.error("No model to export.");
            const atomGroup = currentModel.children.find(c => c instanceof THREE.Group && c.children.every(i => i instanceof THREE.Mesh));
            if (!atomGroup) return console.error("Could not find atom group in model.");
            let csvContent = "x,y,z\n";
            atomGroup.children.forEach(atom => { csvContent += `${atom.position.x},${atom.position.y},${atom.position.z}\n`; });
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.href = url;
            link.download = "mac_model_coordinates.csv";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function setupUI() {
            modelSizeValue.textContent = modelSizeSlider.value;
            packingDensityValue.textContent = packingDensitySlider.value;
            numDefectsValue.textContent = numDefectsSlider.value;
            relaxIterationsValue.textContent = relaxIterationsSlider.value;
            bondLengthStrengthValue.textContent = bondLengthStrengthSlider.value;
            bondAngleStrengthValue.textContent = bondAngleStrengthSlider.value;
            pristineAngleStrengthValue.textContent = pristineAngleStrengthSlider.value;
            zDisplacementStrengthValue.textContent = zDisplacementStrengthSlider.value;
            planarityStrengthValue.textContent = planarityStrengthSlider.value;
            rotationAngleValue.textContent = rotationAngleSlider.value;
            
            modelSizeSlider.addEventListener('input', e => modelSizeValue.textContent = e.target.value);
            packingDensitySlider.addEventListener('input', e => packingDensityValue.textContent = e.target.value);
            numDefectsSlider.addEventListener('input', e => numDefectsValue.textContent = e.target.value);
            relaxIterationsSlider.addEventListener('input', e => relaxIterationsValue.textContent = e.target.value);
            bondLengthStrengthSlider.addEventListener('input', e => bondLengthStrengthValue.textContent = e.target.value);
            bondAngleStrengthSlider.addEventListener('input', e => bondAngleStrengthValue.textContent = e.target.value);
            pristineAngleStrengthSlider.addEventListener('input', e => pristineAngleStrengthValue.textContent = e.target.value);
            zDisplacementStrengthSlider.addEventListener('input', e => zDisplacementStrengthValue.textContent = e.target.value);
            planarityStrengthSlider.addEventListener('input', e => planarityStrengthValue.textContent = e.target.value);
            rotationAngleSlider.addEventListener('input', e => rotationAngleValue.textContent = e.target.value);
            
            regenerateBtn.addEventListener('click', regenerateModel);
            exportCsvBtn.addEventListener('click', exportModelToCsv);
            exportCsvBtn.disabled = true;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            setupUI();
            window.addEventListener('resize', onWindowResize, false);
            generateInitialLatticeView();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>

