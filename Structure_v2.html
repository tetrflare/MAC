<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAC 3D Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #111827; /* Dark background */
            color: #E5E7EB; /* Light text for better contrast */
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(17, 24, 39, 0.5); /* bg-gray-900 with opacity */
            border-radius: 8px;
            z-index: 100;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 1rem;
            background-color: rgba(17, 24, 39, 0.8); /* bg-gray-900 with opacity */
            border-radius: 0.5rem;
            border: 1px solid #374151; /* border-gray-700 */
            width: 280px;
            z-index: 101;
        }

        #controls button:disabled {
            background-color: #374151; /* bg-gray-700 */
            cursor: not-allowed;
        }

        #analysis-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(17, 24, 39, 0.8); /* bg-gray-900 with opacity */
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #374151; /* border-gray-700 */
            width: 280px;
            z-index: 101;
        }

        /* Additional styling for better readability */
        #info h1 {
            color: #FFFFFF; /* White for the main title */
        }
        #info p, #controls label {
            color: #D1D5DB; /* Gray-200 for labels */
        }
        #analysis-results strong {
            color: #F3F4F6; /* Gray-100 for strong text */
        }
    </style>
</head>
<body>

    <div id="info" class="text-white pointer-events-none">
        <h1 class="text-2xl font-bold">MAC 3D Viewer</h1>
        <p class="text-sm">Drag to rotate | Scroll to zoom | Right-click drag to pan</p>
        <p id="status" class="text-xs mt-2 bg-gray-800 bg-opacity-50 inline-block px-2 py-1 rounded"></p>
    </div>

    <div id="controls">
        <div class="mb-4">
            <label for="model-size" class="text-sm text-gray-200">Model Size (<span id="model-size-value">4</span> units)</label>
            <input id="model-size" type="range" min="2" max="8" step="1" value="4" class="w-full">
        </div>
        <div class="mb-4">
            <label for="packing-density" class="text-sm text-gray-200">Initial Packing Density (<span id="packing-density-value">0</span>%)</label>
            <input id="packing-density" type="range" min="-20" max="20" step="1" value="0" class="w-full">
        </div>
        <div class="mb-4">
            <label for="num-defects" class="text-sm text-gray-200">Number of Defects (<span id="num-defects-value">180</span>)</label>
            <input id="num-defects" type="range" min="0" max="1000" value="180" class="w-full">
        </div>
        <div class="mb-4">
            <label for="relax-iterations" class="text-sm text-gray-200">Relaxation Iterations (<span id="relax-iterations-value">500</span>)</label>
            <input id="relax-iterations" type="range" min="0" max="5000" value="500" class="w-full">
        </div>
        <div class="mb-4">
            <label for="bond-length-strength" class="text-sm text-gray-200">Bond Length Strength (<span id="bond-length-strength-value">0.2</span>)</label>
            <input id="bond-length-strength" type="range" min="0" max="1.0" step="0.01" value="0.2" class="w-full">
        </div>
        <div class="mb-4">
            <label for="bond-angle-strength" class="text-sm text-gray-200">Bond Angle Strength (<span id="bond-angle-strength-value">0.002</span>)</label>
            <input id="bond-angle-strength" type="range" min="0.0" max="0.01" step="0.0005" value="0.002" class="w-full">
        </div>
        <div class="mb-4">
            <label for="z-displacement-strength" class="text-sm text-gray-200">Initial Z-Displacement (<span id="z-displacement-strength-value">0.1</span>)</label>
            <input id="z-displacement-strength" type="range" min="0.0" max="1.0" step="0.01" value="0.1" class="w-full">
        </div>
        <div class="mb-4">
            <label for="rotation-angle" class="text-sm text-gray-200">Rotation Angle (<span id="rotation-angle-value">5</span>Â°)</label>
            <input id="rotation-angle" type="range" min="0" max="30" step="1" value="5" class="w-full">
        </div>
        <button id="regenerate-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
            Regenerate
        </button>
        <button id="export-csv-btn" class="mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
            Export CSV
        </button>
    </div>

    <div id="analysis-panel" class="hidden">
        <h3 class="text-lg font-bold mb-2 text-gray-200">Ring Analysis</h3>
        <div id="analysis-results"></div>
    </div>

    <script type="module">
        // Import necessary three.js modules
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls, currentModel;
        const statusElement = document.getElementById('status');
        
        // --- UI Elements ---
        const modelSizeSlider = document.getElementById('model-size');
        const packingDensitySlider = document.getElementById('packing-density');
        const numDefectsSlider = document.getElementById('num-defects');
        const relaxIterationsSlider = document.getElementById('relax-iterations');
        const bondLengthStrengthSlider = document.getElementById('bond-length-strength');
        const bondAngleStrengthSlider = document.getElementById('bond-angle-strength');
        const zDisplacementStrengthSlider = document.getElementById('z-displacement-strength');
        const rotationAngleSlider = document.getElementById('rotation-angle');
        const modelSizeValue = document.getElementById('model-size-value');
        const packingDensityValue = document.getElementById('packing-density-value');
        const numDefectsValue = document.getElementById('num-defects-value');
        const relaxIterationsValue = document.getElementById('relax-iterations-value');
        const bondLengthStrengthValue = document.getElementById('bond-length-strength-value');
        const bondAngleStrengthValue = document.getElementById('bond-angle-strength-value');
        const zDisplacementStrengthValue = document.getElementById('z-displacement-strength-value');
        const rotationAngleValue = document.getElementById('rotation-angle-value');
        const regenerateBtn = document.getElementById('regenerate-btn');
        const exportCsvBtn = document.getElementById('export-csv-btn');


        // --- Default Generation Configuration ---
        const config = {
            C_C_BOND_LENGTH: 1.42,
            IDEAL_BOND_ANGLE: 2 * Math.PI / 3, // 120 degrees in radians
            BOND_THRESHOLD_FACTOR: 1.2,
            MIN_BOND_LENGTH_FACTOR: 0.8,
            ATOM_RADIUS: 0.3,
            BOND_RADIUS: 0.08,
        };
        
        function generateGrapheneLattice(numCellsX, numCellsY, packingFactor, angleInDegrees) {
            statusElement.textContent = 'Generating perfect graphene lattice...';
            const atomMap = new Map(); // Use a map to store unique atoms with their tile info
            const atom_dist = config.C_C_BOND_LENGTH * packingFactor;
            
            // Lattice vectors for the primitive cell
            const a1 = new THREE.Vector3(atom_dist * 3 / 2, atom_dist * Math.sqrt(3) / 2, 0);
            const a2 = new THREE.Vector3(atom_dist * 3 / 2, -atom_dist * Math.sqrt(3) / 2, 0);
            
            // Basis atoms within the primitive cell
            const b1 = new THREE.Vector3(0, 0, 0);
            const b2 = new THREE.Vector3(atom_dist, 0, 0);

            // 1. Predefine a single 4x4 unit cell and find its center.
            const baseUnitCellAtoms = [];
            const unitSize = 4;
            const unitCellBox = new THREE.Box3(); // To calculate the center
            for (let i = 0; i < unitSize; i++) {
                for (let j = 0; j < unitSize; j++) {
                    const R = new THREE.Vector3().addScaledVector(a1, i).addScaledVector(a2, j);
                    const p1 = new THREE.Vector3().addVectors(R, b1);
                    const p2 = new THREE.Vector3().addVectors(R, b2);
                    baseUnitCellAtoms.push(p1);
                    baseUnitCellAtoms.push(p2);
                    unitCellBox.expandByPoint(p1);
                    unitCellBox.expandByPoint(p2);
                }
            }
            const unitCellCenter = unitCellBox.getCenter(new THREE.Vector3());

            // Rotation setup for the 'green' tiles
            const rotationAngle = angleInDegrees * (Math.PI / 180); // Convert degrees to radians
            const rotationAxis = new THREE.Vector3(0, 0, 1);

            // 2. Define the translation vectors based on the size of the 4x4 unit
            const translationVectorX = new THREE.Vector3().addScaledVector(a1, unitSize);
            const translationVectorY = new THREE.Vector3().addScaledVector(a2, unitSize);

            // 3. Duplicate (tile) the pre-defined unit to fill the total desired space
            const numTranslationsX = Math.ceil(numCellsX / unitSize);
            const numTranslationsY = Math.ceil(numCellsY / unitSize);

            for (let m = -numTranslationsX; m <= numTranslationsX; m++) {
                for (let n = -numTranslationsY; n <= numTranslationsY; n++) {
                    const totalTranslation = new THREE.Vector3().addScaledVector(translationVectorX, m).addScaledVector(translationVectorY, n);
                    const isRotatedTile = (m + n) % 2 !== 0;

                    if (isRotatedTile) {
                        // This is a 'green' tile, which we will rotate.
                        const tileCenter = new THREE.Vector3().addVectors(totalTranslation, unitCellCenter);
                        
                        baseUnitCellAtoms.forEach(atomLocalPos => {
                            // 1. Get atom's position relative to its own unit cell's center.
                            const posRelativeToUnitCenter = new THREE.Vector3().subVectors(atomLocalPos, unitCellCenter);
                            
                            // 2. Rotate it.
                            posRelativeToUnitCenter.applyAxisAngle(rotationAxis, rotationAngle);

                            // 3. Move it to the final tile's global center to get the final position.
                            const finalPos = new THREE.Vector3().addVectors(posRelativeToUnitCenter, tileCenter);
                            
                            const key = `${finalPos.x.toFixed(4)},${finalPos.y.toFixed(4)},${finalPos.z.toFixed(4)}`;
                            if (!atomMap.has(key)) {
                                atomMap.set(key, { pos: [finalPos.x, finalPos.y, finalPos.z], tile: { m, n } });
                            }
                        });
                    } else {
                        // This is a 'blue' tile. Place it without rotation.
                        baseUnitCellAtoms.forEach(atomPos => {
                            const newPos = new THREE.Vector3().addVectors(atomPos, totalTranslation);
                            const key = `${newPos.x.toFixed(4)},${newPos.y.toFixed(4)},${newPos.z.toFixed(4)}`;
                            if (!atomMap.has(key)) {
                                atomMap.set(key, {
                                    pos: [newPos.x, newPos.y, newPos.z],
                                    tile: { m, n }
                                });
                            }
                        });
                    }
                }
            }
            
            return Array.from(atomMap.values());
        }

        function introduceStoneWalesDefects(atomData, defectCount, threshold) {
            statusElement.textContent = 'Introducing defects...';
            if (defectCount === 0) return atomData;
            
            let positions = atomData.map(a => new THREE.Vector3(...a.pos));

            let createdDefects = 0;
            let totalAttempts = 0;
            const maxTotalAttempts = defectCount * 200; 

            while (createdDefects < defectCount && totalAttempts < maxTotalAttempts) {
                totalAttempts++;
                const adj = new Map(positions.map((_, i) => [i, []]));
                const bonds = [];
                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        if (positions[i].distanceTo(positions[j]) < threshold) {
                            adj.get(i).push(j);
                            adj.get(j).push(i);
                            bonds.push([i, j]);
                        }
                    }
                }
                
                if (bonds.length === 0) break;

                const randomBond = bonds[Math.floor(Math.random() * bonds.length)];
                const [i, j] = randomBond;
                if (adj.get(i).length !== 3 || adj.get(j).length !== 3) {
                    continue; 
                }

                const p_i = positions[i];
                const p_j = positions[j];
                
                const midpoint = new THREE.Vector3().addVectors(p_i, p_j).multiplyScalar(0.5);
                const rotationAxis = new THREE.Vector3(0, 0, 1);
                const p_i_new = p_i.clone().sub(midpoint).applyAxisAngle(rotationAxis, Math.PI / 2).add(midpoint);
                const p_j_new = p_j.clone().sub(midpoint).applyAxisAngle(rotationAxis, Math.PI / 2).add(midpoint);

                let clashes = false;
                const minDistance = config.C_C_BOND_LENGTH * config.MIN_BOND_LENGTH_FACTOR;
                for (let k = 0; k < positions.length; k++) {
                    if (k === i || k === j) continue;
                    
                    const p_k = positions[k];
                    if (p_i_new.distanceTo(p_k) < minDistance || p_j_new.distanceTo(p_k) < minDistance) {
                        clashes = true;
                        break;
                    }
                }

                if (!clashes) {
                    positions[i].copy(p_i_new);
                    positions[j].copy(p_j_new);
                    createdDefects++;
                    if (createdDefects % 10 === 0 || createdDefects === defectCount) {
                        statusElement.textContent = `Introducing defects... (${createdDefects}/${defectCount})`;
                    }
                }
            }
            
            console.log(`Successfully introduced ${createdDefects} defects after ${totalAttempts} attempts.`);
            return atomData.map((data, i) => ({
                pos: [positions[i].x, positions[i].y, positions[i].z],
                tile: data.tile
            }));
        }
        
        function addInitialZDisplacement(atomData, zStrength) {
            if (zStrength === 0) return atomData;
            statusElement.textContent = 'Applying initial Z-displacement...';
            return atomData.map(data => ({
                pos: [data.pos[0], data.pos[1], (Math.random() - 0.5) * zStrength],
                tile: data.tile
            }));
        }

        function determineBondNetwork(atoms) {
            statusElement.textContent = 'Determining 3-bond network...';
            const bonds = new Set();
            const atomVectors = atoms.map(a => new THREE.Vector3(...a));

            for (let i = 0; i < atomVectors.length; i++) {
                const neighbors = [];
                for (let j = 0; j < atomVectors.length; j++) {
                    if (i === j) continue;
                    const distance = atomVectors[i].distanceTo(atomVectors[j]);
                    neighbors.push({ index: j, distance: distance });
                }
                neighbors.sort((a, b) => a.distance - b.distance);
                const nearestNeighbors = neighbors.slice(0, 3);
                for (const neighbor of nearestNeighbors) {
                    const bondKey = `${Math.min(i, neighbor.index)}-${Math.max(i, neighbor.index)}`;
                    bonds.add(bondKey);
                }
            }
            return Array.from(bonds).map(b => b.split('-').map(Number));
        }

        function refineBondNetwork(atoms, initialBonds) {
            statusElement.textContent = 'Refining bond network...';
            console.log('Refining bond network with small ring removal...');
            let bonds = new Set(initialBonds.map(b => `${Math.min(b[0], b[1])}-${Math.max(b[0], b[1])}`));
            const atomVectors = atoms.map(a => new THREE.Vector3(...a));
            const maxIterations = 10; // Increased iterations for more complex refinement

            // --- New Helper Function to find and remove small rings ---
            const findAndRemoveSmallestRings = (currentBonds, adj) => {
                const bondsToRemove = new Set();
                
                // Find 3-membered rings (triangles)
                for (let i = 0; i < atomVectors.length; i++) {
                    const neighbors = adj.get(i);
                    if (neighbors.length < 2) continue;
                    for (let j_idx = 0; j_idx < neighbors.length; j_idx++) {
                        for (let k_idx = j_idx + 1; k_idx < neighbors.length; k_idx++) {
                            const j = neighbors[j_idx];
                            const k = neighbors[k_idx];
                            // Check if j and k are neighbors
                            if (adj.get(j).includes(k)) {
                                // Found a triangle: i-j-k
                                const ringAtoms = [i, j, k];
                                const ringBonds = [
                                    { atoms: [i, j], dist: atomVectors[i].distanceTo(atomVectors[j]) },
                                    { atoms: [j, k], dist: atomVectors[j].distanceTo(atomVectors[k]) },
                                    { atoms: [k, i], dist: atomVectors[k].distanceTo(atomVectors[i]) }
                                ];
                                ringBonds.sort((a, b) => b.dist - a.dist);
                                const bondToRemove = ringBonds[0].atoms;
                                bondsToRemove.add(`${Math.min(bondToRemove[0], bondToRemove[1])}-${Math.max(bondToRemove[0], bondToRemove[1])}`);
                            }
                        }
                    }
                }
                
                // Find 4-membered rings
                for (let i = 0; i < atomVectors.length; i++) {
                    const neighbors_of_i = adj.get(i);
                     for (const j of neighbors_of_i) {
                         if (i > j) continue;
                         const commonNeighbors = (adj.get(i) || []).filter(n => (adj.get(j) || []).includes(n));
                         if (commonNeighbors.length > 0) continue; // Skip if part of a 3-ring

                         for (const k of adj.get(j)) {
                             if (k === i) continue;
                             for (const l of adj.get(k)) {
                                 if (l === j || l === i) continue;
                                 if (adj.get(l).includes(i)) {
                                     // Found a 4-ring: i-j-k-l
                                     const ringBonds = [
                                         {atoms: [i,j], dist: atomVectors[i].distanceTo(atomVectors[j])},
                                         {atoms: [j,k], dist: atomVectors[j].distanceTo(atomVectors[k])},
                                         {atoms: [k,l], dist: atomVectors[k].distanceTo(atomVectors[l])},
                                         {atoms: [l,i], dist: atomVectors[l].distanceTo(atomVectors[i])}
                                     ];
                                     ringBonds.sort((a,b)=>b.dist - a.dist);
                                     const bondToRemove = ringBonds[0].atoms;
                                     bondsToRemove.add(`${Math.min(bondToRemove[0], bondToRemove[1])}-${Math.max(bondToRemove[0], bondToRemove[1])}`);
                                 }
                             }
                         }
                     }
                }


                bondsToRemove.forEach(bondKey => {
                    if (currentBonds.has(bondKey)) {
                        currentBonds.delete(bondKey);
                    }
                });
                return bondsToRemove;
            };

            for (let iter = 0; iter < maxIterations; iter++) {
                let changesMade = false;
                
                // Build adjacency list for this iteration
                let adj = new Map(atomVectors.map((_, i) => [i, []]));
                const bondList = Array.from(bonds).map(b => b.split('-').map(Number));
                for(const [u,v] of bondList) {
                    adj.get(u).push(v);
                    adj.get(v).push(u);
                }

                // --- PRIORITY 1: Remove small rings ---
                const bondsBrokenThisCycle = findAndRemoveSmallestRings(bonds, adj);
                if (bondsBrokenThisCycle.size > 0) {
                    changesMade = true;
                    // Rebuild adjacency list after removing bonds
                    adj = new Map(atomVectors.map((_, i) => [i, []]));
                    const newBondList = Array.from(bonds).map(b => b.split('-').map(Number));
                    for(const [u,v] of newBondList) {
                        adj.get(u).push(v);
                        adj.get(v).push(u);
                    }
                }


                // --- PRIORITY 2: Fix over-coordination ---
                for(let i=0; i<atomVectors.length; i++) {
                    if (adj.get(i).length > 3) {
                        const neighbors = adj.get(i);
                        neighbors.sort((a, b) => atomVectors[i].distanceTo(atomVectors[b]) - atomVectors[i].distanceTo(atomVectors[a]));
                        const toRemove = neighbors.slice(3); // Keep only the 3 closest
                        for(const neighborToRemove of toRemove) {
                            const bondKey = `${Math.min(i, neighborToRemove)}-${Math.max(i, neighborToRemove)}`;
                            if(bonds.has(bondKey)) {
                                bonds.delete(bondKey);
                                changesMade = true;
                            }
                        }
                    }
                }
                
                if(changesMade) { // Rebuild adj list if bonds were removed
                    adj = new Map(atomVectors.map((_, i) => [i, []]));
                    const newBondList = Array.from(bonds).map(b => b.split('-').map(Number));
                     for(const [u,v] of newBondList) {
                        adj.get(u).push(v);
                        adj.get(v).push(u);
                    }
                }

                // --- PRIORITY 3: Fix under-coordination ---
                for(let i=0; i<atomVectors.length; i++) {
                    if(adj.get(i).length < 3) {
                        const candidates = [];
                        for(let j=0; j<atomVectors.length; j++) {
                           if(i === j || adj.get(i).includes(j)) continue;
                           const dist = atomVectors[i].distanceTo(atomVectors[j]);
                           if(dist < config.C_C_BOND_LENGTH * 1.5) { // Broaden search slightly
                               candidates.push({index: j, distance: dist});
                           }
                        }
                        candidates.sort((a,b) => a.distance - b.distance);
                        
                        for(const candidate of candidates) {
                            if(adj.get(i).length >= 3) break;
                            const j = candidate.index;
                            if (adj.get(j) && adj.get(j).length >= 3) continue; // Don't connect to already saturated atoms

                            const bondKey = `${Math.min(i, j)}-${Math.max(i, j)}`;
                            if (bondsBrokenThisCycle.has(bondKey)) continue; // Don't re-form a bond that was just broken in this cycle.

                            if(!bonds.has(bondKey) && !checkIfFormsSmallRing(i, j, adj)) {
                                bonds.add(bondKey);
                                adj.get(i).push(j);
                                adj.get(j).push(i);
                                changesMade = true;
                            }
                        }
                    }
                }
                if (!changesMade) break; // Exit loop if structure is stable
            }


            return Array.from(bonds).map(b => b.split('-').map(Number));
        }
        
        function checkIfFormsSmallRing(u, v, adj) {
            const uNeighbors = adj.get(u);
            const vNeighbors = adj.get(v);

            // Check for 3-membered rings (u and v share a common neighbor)
            for(const n of uNeighbors) {
                if(vNeighbors.includes(n)) return true;
            }
            
            // Check for 4-membered rings (a neighbor of u is connected to a neighbor of v)
            for (const u_neighbor of uNeighbors) {
                for (const v_neighbor of vNeighbors) {
                    if (adj.get(u_neighbor).includes(v_neighbor)) {
                        return true;
                    }
                }
            }

            return false;
        }

        function relaxStructure(atomData, bonds, iterations, lengthStrength, angleStrength, idealLength, idealAngle) {
             console.log(`Relaxing structure for ${iterations} iterations...`);
             let positions = atomData.map(a => new THREE.Vector3(...a.pos));
             
             const adj = new Map(positions.map((_, i) => [i, []]));
             for(const [u,v] of bonds) {
                 adj.get(u).push(v);
                 adj.get(v).push(u);
             }

             for (let i = 0; i < iterations; i++) {
                if (i % 5 === 0) statusElement.textContent = `Relaxing structure... (Iteration ${i + 1}/${iterations})`;
                const forces = positions.map(() => new THREE.Vector3(0, 0, 0));

                for (const bond of bonds) {
                    const [j, k] = bond;
                    const p1 = positions[j], p2 = positions[k];
                    const delta = new THREE.Vector3().subVectors(p2, p1);
                    const distance = delta.length();
                    if (distance > 0.1) {
                        const displacement = distance - idealLength;
                        const forceMagnitude = lengthStrength * displacement;
                        const force = delta.normalize().multiplyScalar(forceMagnitude);
                        forces[j].add(force);
                        forces[k].sub(force);
                    }
                }
                
                if (angleStrength > 0) {
                    const effectiveAngleStrength = angleStrength * 10; 
                    for (let j = 0; j < positions.length; j++) {
                        const neighbors = adj.get(j);
                        if (neighbors.length < 2) continue;
                        
                        for (let n1 = 0; n1 < neighbors.length; n1++) {
                            for (let n2 = n1 + 1; n2 < neighbors.length; n2++) {
                                const p_center = positions[j];
                                const p_n1 = positions[neighbors[n1]];
                                const p_n2 = positions[neighbors[n2]];
                                const v1 = new THREE.Vector3().subVectors(p_n1, p_center);
                                const v2 = new THREE.Vector3().subVectors(p_n2, p_center);

                                if (v1.lengthSq() === 0 || v2.lengthSq() === 0) continue;

                                const currentAngle = v1.angleTo(v2);
                                const angleDisplacement = currentAngle - idealAngle;
                                
                                const forceMagnitude = effectiveAngleStrength * Math.sign(angleDisplacement) * Math.pow(angleDisplacement, 2);

                                const cross = new THREE.Vector3().crossVectors(v1, v2);
                                if (cross.lengthSq() > 1e-8) {
                                    const forceDir1 = new THREE.Vector3().crossVectors(v1, v2).cross(v1).normalize();
                                    forces[neighbors[n1]].add(forceDir1.multiplyScalar(forceMagnitude));
                                    const forceDir2 = new THREE.Vector3().crossVectors(v2, v1).cross(v2).normalize();
                                    forces[neighbors[n2]].add(forceDir2.multiplyScalar(forceMagnitude));
                                }
                            }
                        }
                    }
                }
                
                positions.forEach((pos, index) => pos.add(forces[index]));
            }
            statusElement.textContent = 'Relaxation complete.';
            return atomData.map((data, i) => ({
                pos: [positions[i].x, positions[i].y, positions[i].z],
                tile: data.tile
            }));
        }

        function analyzeRings(bonds, numAtoms) {
            statusElement.textContent = 'Analyzing ring structure...';
            console.log('Analyzing ring structure with new per-bond method...');
            const adj = new Map();
            for (let i = 0; i < numAtoms; i++) adj.set(i, []);
            for (const [u, v] of bonds) {
                adj.get(u).push(v);
                adj.get(v).push(u);
            }

            const ringCounts = { 3:0, 4:0, 5: 0, 6: 0, 7: 0, 8: 0, "9+": 0 };
            const bondsInNonSixRings = new Set();

            const bfs = (start, end, excludedNodes = new Set()) => {
                const q = [[start, [start]]];
                const visited = new Set([start, ...excludedNodes]);
                
                while (q.length > 0) {
                    const [curr, path] = q.shift();
                    if (curr === end) return path;
                    
                    for (const neighbor of (adj.get(curr) || [])) {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            const newPath = [...path, neighbor];
                            q.push([neighbor, newPath]);
                        }
                    }
                }
                return null;
            };

            for (const bond of bonds) {
                const [u, v] = bond;
                
                const adj_u = adj.get(u);
                const adj_v = adj.get(v);
                adj.set(u, adj_u.filter(n => n !== v));
                adj.set(v, adj_v.filter(n => n !== u));

                let inNonSix = false;
                const path1 = bfs(u, v);
                if (path1) {
                    const size1 = path1.length;
                    if (size1 !== 6) inNonSix = true;
                    if (ringCounts.hasOwnProperty(size1)) ringCounts[size1] += 1 / size1;
                    else if (size1 >= 9) ringCounts["9+"] += 1 / size1;

                    const excluded = new Set(path1.slice(1, -1));
                    const path2 = bfs(u, v, excluded);
                    if (path2) {
                        const size2 = path2.length;
                         if (size2 !== 6) inNonSix = true;
                         if (ringCounts.hasOwnProperty(size2)) ringCounts[size2] += 1 / size2;
                         else if (size2 >= 9) ringCounts["9+"] += 1 / size2;
                    }
                }

                if(inNonSix) {
                    bondsInNonSixRings.add(`${Math.min(u,v)}-${Math.max(u,v)}`);
                }

                adj.set(u, adj_u);
                adj.set(v, adj_v);
            }
            
            const totalRings = Object.values(ringCounts).reduce((sum, val) => sum + val, 0);
            
            const resultsPanel = document.getElementById('analysis-panel');
            const resultsDiv = document.getElementById('analysis-results');
            resultsDiv.innerHTML = '';

            if (totalRings === 0) {
                resultsDiv.innerHTML = '<p class="text-sm text-gray-400">No rings found.</p>';
            } else {
                const categories = [
                    { size: 3, label: '3-Membered' },
                    { size: 4, label: '4-Membered' },
                    { size: 5, label: '5-Membered' },
                    { size: 6, label: '6-Membered' },
                    { size: 7, label: '7-Membered' },
                    { size: 8, label: '8-Membered' },
                    { size: "9+", label: '9+ Membered' }
                ];

                for (const category of categories) {
                    const count = ringCounts[category.size] || 0;
                    const fraction = totalRings > 0 ? (count / totalRings) * 100 : 0;
                    const p = document.createElement('p');
                    p.className = 'text-sm text-gray-300 flex justify-between';
                    p.innerHTML = `<strong>${category.label}:</strong> <span>${Math.round(count)} <span class="text-gray-500">(${fraction.toFixed(1)}%)</span></span>`;
                    resultsDiv.appendChild(p);
                }
            }
            resultsPanel.classList.remove('hidden');
            return { bondsInNonSixRings };
        }
        
        function createBond(p1, p2, material, group) {
            const bondDir = new THREE.Vector3().subVectors(p2, p1);
            const bondLength = bondDir.length();
            if (bondLength === 0) return;
            const bondGeometry = new THREE.CylinderGeometry(config.BOND_RADIUS, config.BOND_RADIUS, bondLength, 8);
            const bondMesh = new THREE.Mesh(bondGeometry, material);
            bondMesh.position.copy(p1).add(bondDir.multiplyScalar(0.5));
            bondMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), bondDir.normalize());
            group.add(bondMesh);
        }

        function createModel(atomData, bonds, bondsInNonSixRings) {
            const atomGroup = new THREE.Group();
            const bondGroup = new THREE.Group();
            
            // --- Blue/Grey Color Scheme ---
            const blueAtomMaterial = new THREE.MeshStandardMaterial({ color: 0x2563eb, roughness: 0.5 }); // Blue
            const blueBondMaterial = new THREE.MeshStandardMaterial({ color: 0x1d4ed8, roughness: 0.5 }); // Darker Blue
            const greyAtomMaterial = new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness: 0.5 }); // Grey
            const greyBondMaterial = new THREE.MeshStandardMaterial({ color: 0x4b5563, roughness: 0.5 }); // Darker Grey

            // Find all atoms involved in non-six-membered rings
            const defectiveAtoms = new Set();
            bondsInNonSixRings.forEach(bondKey => {
                const [u, v] = bondKey.split('-').map(Number);
                defectiveAtoms.add(u);
                defectiveAtoms.add(v);
            });
            
            const atomGeometry = new THREE.SphereGeometry(config.ATOM_RADIUS, 16, 16);
            const atoms = atomData.map(data => ({
                pos: new THREE.Vector3(...data.pos),
                // tile data is no longer used for coloring but is kept for data consistency
                tile: data.tile 
            }));

            atoms.forEach((atom, i) => {
                const material = defectiveAtoms.has(i) ? greyAtomMaterial : blueAtomMaterial;
                const atomMesh = new THREE.Mesh(atomGeometry, material);
                atomMesh.position.copy(atom.pos);
                atomGroup.add(atomMesh);
            });
            
            for (const bond of bonds) {
                const [i, j] = bond;
                const bondKey = `${Math.min(i, j)}-${Math.max(i, j)}`;
                const material = bondsInNonSixRings.has(bondKey) ? greyBondMaterial : blueBondMaterial;
                createBond(atoms[i].pos, atoms[j].pos, material, bondGroup);
            }

            const modelGroup = new THREE.Group();
            modelGroup.add(atomGroup);
            modelGroup.add(bondGroup);
            const boundingBox = new THREE.Box3().setFromObject(modelGroup);
            const center = boundingBox.getCenter(new THREE.Vector3());
            modelGroup.position.sub(center);
            return modelGroup;
        }
        
        function regenerateModel() {
            regenerateBtn.disabled = true;
            regenerateBtn.textContent = 'Generating...';
            exportCsvBtn.disabled = true;
            if (currentModel) scene.remove(currentModel);
            
            setTimeout(() => {
                const modelSizeUnits = parseInt(modelSizeSlider.value);
                const packingDensity = parseInt(packingDensitySlider.value);
                const numDefects = parseInt(numDefectsSlider.value);
                const relaxIterations = parseInt(relaxIterationsSlider.value);
                const lengthStrength = parseFloat(bondLengthStrengthSlider.value);
                const angleStrength = parseFloat(bondAngleStrengthSlider.value);
                const zStrength = parseFloat(zDisplacementStrengthSlider.value);
                const rotationAngle = parseInt(rotationAngleSlider.value);
                
                const packingFactor = 1 - (packingDensity / 100);
                const bondThreshold = config.C_C_BOND_LENGTH * config.BOND_THRESHOLD_FACTOR * packingFactor;

                // Calculate the number of cells based on the new model size parameter
                const unitCellDimension = 4; // This is the 'unitSize' from generateGrapheneLattice
                const numCells = modelSizeUnits * unitCellDimension;

                let initialAtoms = generateGrapheneLattice(numCells, numCells, packingFactor, rotationAngle);
                let defectedAtoms = introduceStoneWalesDefects(initialAtoms, numDefects, bondThreshold);
                let displacedAtoms = addInitialZDisplacement(defectedAtoms, zStrength);
                
                // Extract only positions for functions that don't need tile info
                const atomPositions = displacedAtoms.map(d => d.pos);
                let bondNetwork = determineBondNetwork(atomPositions);
                bondNetwork = refineBondNetwork(atomPositions, bondNetwork);
                
                const analysisResult = analyzeRings(bondNetwork, displacedAtoms.length);
                
                // Pass the full data (with tile info) to the relaxation function
                let relaxedAtoms = relaxStructure(displacedAtoms, bondNetwork, relaxIterations, lengthStrength, angleStrength, config.C_C_BOND_LENGTH, config.IDEAL_BOND_ANGLE);
                
                statusElement.textContent = 'Creating 3D objects...';
                currentModel = createModel(relaxedAtoms, bondNetwork, analysisResult.bondsInNonSixRings);
                scene.add(currentModel);

                statusElement.style.display = 'none';
                regenerateBtn.disabled = false;
                regenerateBtn.textContent = 'Regenerate';
                exportCsvBtn.disabled = false;

                // --- Corrected Camera Framing Logic ---
                const boundingBox = new THREE.Box3().setFromObject(currentModel);
                const modelCenter = boundingBox.getCenter(new THREE.Vector3());
                const modelSizeVec = boundingBox.getSize(new THREE.Vector3());
                const modelSize = Math.max(modelSizeVec.x, modelSizeVec.y, modelSizeVec.z);
                
                const fov = camera.fov * (Math.PI / 180);
                const cameraDistance = (modelSize / 2) / Math.tan(fov / 2);

                const padding = 1.2; 
                camera.position.set(modelCenter.x, modelCenter.y, modelCenter.z + cameraDistance * padding);
                
                camera.near = cameraDistance / 100;
                camera.far = cameraDistance * 100;
                camera.updateProjectionMatrix();
                
                controls.target.copy(modelCenter);
                controls.update();
            }, 50);
        }

        // Function to export model coordinates as a CSV file
        function exportModelToCsv() {
            if (!currentModel) {
                console.error("No model to export.");
                return;
            }

            // Find the atom group within the main model group
            const atomGroup = currentModel.children.find(child => child instanceof THREE.Group && child.children.every(c => c instanceof THREE.Mesh));

            if (!atomGroup) {
                console.error("Could not find atom group in model.");
                return;
            }

            let csvContent = "x,y,z\n";

            atomGroup.children.forEach(atom => {
                const { x, y, z } = atom.position;
                csvContent += `${x},${y},${z}\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "mac_model_coordinates.csv");
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        function setupUI() {
            modelSizeValue.textContent = modelSizeSlider.value;
            packingDensityValue.textContent = packingDensitySlider.value;
            numDefectsValue.textContent = numDefectsSlider.value;
            relaxIterationsValue.textContent = relaxIterationsSlider.value;
            bondLengthStrengthValue.textContent = bondLengthStrengthSlider.value;
            bondAngleStrengthValue.textContent = bondAngleStrengthSlider.value;
            zDisplacementStrengthValue.textContent = zDisplacementStrengthSlider.value;
            rotationAngleValue.textContent = rotationAngleSlider.value;
            
            modelSizeSlider.addEventListener('input', (e) => modelSizeValue.textContent = e.target.value);
            packingDensitySlider.addEventListener('input', (e) => packingDensityValue.textContent = e.target.value);
            numDefectsSlider.addEventListener('input', (e) => numDefectsValue.textContent = e.target.value);
            relaxIterationsSlider.addEventListener('input', (e) => relaxIterationsValue.textContent = e.target.value);
            bondLengthStrengthSlider.addEventListener('input', (e) => {
                bondLengthStrengthValue.textContent = e.target.value;
            });
             bondAngleStrengthSlider.addEventListener('input', (e) => {
                bondAngleStrengthValue.textContent = e.target.value;
            });
            zDisplacementStrengthSlider.addEventListener('input', (e) => {
                zDisplacementStrengthValue.textContent = e.target.value;
            });
            rotationAngleSlider.addEventListener('input', (e) => rotationAngleValue.textContent = e.target.value);
            regenerateBtn.addEventListener('click', regenerateModel);
            exportCsvBtn.addEventListener('click', exportModelToCsv);
            exportCsvBtn.disabled = true; // Disable until the first model is generated
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            setupUI();
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>





